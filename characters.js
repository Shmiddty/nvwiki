const fs = require('fs').promises
const db = require('./db.js')
const bot = require('mwbot')
const atl = require('atlas-parser')
const jimp = require('jimp')
const { GifFrame, GifUtil } = require('gifwrap')
const cliProgress = require('cli-progress')
const { apiUrl, apiLimit, concurrency } = require('./mwconfig.json')
const { character, cargoCharacterQuery, license } = require('./wiki.js')
const { str, stagger, mwContinuedRequest } = require('./util.js')
const toString = (o) => o.toString()

const client = new bot({
  verbose: false,
  silent: true,
  concurrency
})

const DRY = process.env.DRY === '1'
const OW = process.env.OW === '1'
const OWI = process.env.OWI === '1'
const DMP = process.env.DMP === '1'

const prog = new cliProgress.SingleBar(
  {
    format: '{bar} | {percentage}% | ETA: {eta}s | {value}/{total} | {name}'
  },
  cliProgress.Presets.shades_classic
)
prog.increment = prog.increment.bind(prog)
prog.stop = prog.stop.bind(prog)

Promise.all([
  fs
    .readFile('./credentials.secret')
    .then(toString)
    .then((str) => str.split('\n')),
  fs.readFile('./lib/nv/gamedata.json').then(toString).then(JSON.parse),
  fs.readFile('./lib/nv/Characters.atlas').then(str).then(atl.parse),
  jimp.read('./lib/nv/Characters.png')
]).then(async ([[username, password], data, charsAtl, charsImg]) => {
  const $db = db(data)

  const { csrftoken: token } = await client.loginGetEditToken({
    apiUrl,
    username,
    password
  })

  const timeStep = Math.ceil(apiLimit.period / apiLimit.count)

  // --- Images --- //
  const exImgs = await mwContinuedRequest(client, {
    action: 'query',
    list: 'allimages',
    ailimit: 500,
    token
  }).then((imgs) => {
    return imgs.map((i) => i.name.toLowerCase().slice(0, -4))
  })
  const imgs = Object.entries(charsAtl['Characters.png'].frames).filter(
    ([k]) =>
      (k.includes('idle') ||
        /npc_.*state0/.test(k) ||
        k.includes('flameseeker')) &&
      (OWI || !exImgs.includes(k.replace(/state./, 'idle').replace(/\//g, '_')))
  )

  console.log('\nGenerating Gifs:\n')
  prog.start(imgs.length, 0, { name: '' })
  await Promise.all(
    imgs.map(async ([k, frames], i) => {
      const fname = k.replace(/\//g, '_').replace(/state./, 'idle') + '.gif'
      prog.update(i + 1, { name: fname })
      const maxW = Math.max(...frames.map((v) => v.size[0]))
      const maxH = Math.max(...frames.map((v) => v.size[1]))
      const minXoff = Math.min(...frames.map((v) => v.offset[0]))
      const minYoff = Math.min(...frames.map((v) => v.offset[1]))
      const frms = await Promise.all(
        frames.map(async (v) => {
          const [w, h] = v.size
          const [x, y] = v.offset
          const dX = Math.ceil((maxW - w) / 2 + (x - minXoff) / 2)
          const dY = Math.ceil(maxH - h + (y - minYoff) / 2)

          const frame = await charsImg.clone().crop(...v.xy, ...v.size)
          return new GifFrame(frame.bitmap, {
            xOffset: dX,
            yOffset: dY,
            delayCentisecs: 10
          })
        })
      )

      return GifUtil.write(`./dist/${fname}`, frms, { loops: 0 })
    })
  ).finally(prog.stop)

  console.log('\nUploading images:\n')
  prog.start(imgs.length, 0, { name: '' })

  await stagger(imgs, timeStep, async ([k], i) => {
    const fname = k.replace(/\//g, '_').replace(/state./, 'idle') + '.gif'
    prog.update(i + 1, { name: fname })

    const fPath = `./dist/${fname}`

    if (DRY) return

    return client
      .upload(fname, fPath, 'Uploaded by nvwikibot', {
        text: license('Casey Clyde'),
        ignorewarnings: OWI
      })
      .catch(console.error)
  }).finally(prog.stop)

  // --- Characters --- //
  const chars = await $db.characters()
  const exPages = await mwContinuedRequest(client, {
    action: 'query',
    list: 'allpages',
    aplimit: 500,
    token
  }).then((pages) => pages.map((i) => i.title))
  const newChars = chars.filter((i) => OW || !exPages.includes(i.name))

  console.log('\nUpdating characters:\n')
  prog.start(newChars.length, 0, { name: '' })

  await stagger(newChars, timeStep, (char, i) => {
    prog.update(i + 1, { name: char.name })
    const anim = char.visual[0]?.anim
    char.icon = anim ? anim + '_idle.gif' : ''
    const content = character(char)

    if (DMP) console.log(content)
    if (DRY) return

    return client
      .edit(char.name, content, 'Generated by nvwikibot', { token })
      .catch(console.error)
  }).finally(prog.stop)

  // --- Teams --- //
  const teams = Object.entries(await $db.charactersByTeam())
  const newTeams = teams.filter(
    ([k]) => k !== 'Other' && (OW || !exPages.includes(k))
  )

  console.log('\nUpdating Teams:\n')
  prog.start(newTeams.length, 0, { name: '' })
  await stagger(newTeams, timeStep, ([team, chars], i) => {
    prog.update(i + 1, { name: team })
    const content = cargoCharacterQuery(`team='${team}'`, { team: true })

    if (DMP) console.log(content)
    if (DRY) return

    return client
      .edit(team, content, 'Generated by nvwikibot', { token })
      .catch(console.error)
  }).finally(prog.stop)

  // --- Types --- //
  const types = Object.entries(await $db.charactersByType())
  const newTypes = types.filter(
    ([k]) => k !== 'Other' && (OW || !exPages.includes(k))
  )

  console.log('\nUpdating Types:\n')
  prog.start(newTypes.length, 0, { name: '' })
  await stagger(newTypes, timeStep, ([type, chars], i) => {
    prog.update(i + 1, { name: type })
    const content = cargoCharacterQuery(`type='${type}'`, { type: true })

    if (DMP) console.log(content)
    if (DRY) return

    return client
      .edit(type, content, 'Generated by nvwikibot', { token })
      .catch(console.error)
  }).finally(prog.stop)
})
